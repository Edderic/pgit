#!/usr/bin/env ruby
require 'gli'
require 'pgit'
include GLI::App

program_desc 'Optimize your Pivotal Tracker and Git workflow'

version Pgit::VERSION

subcommand_option_handling :normal
arguments :strict

desc "Color output"
default_value :true
switch :color

# desc 'Path to the config file'
# default_value "#{ENV['HOME']}/.pgit.rc.yml"
# arg_name '/path/to/.pivotal.yml'
# flag [:c,:config]

# desc 'Bypasses the app asking for confirmation'
# switch [:force]

# desc 'PivotalTracker API Token'
# arg_name 'secr3tT0ken123'
# flag [:'api-token']
desc "Work with custom commands defined in the current project"
command :command do |c|
  c.desc "show the custom command(s)"
  c.arg_name 'command_name'
  c.command :show do |s|
    s.action do |global_options,options,args|
      app = PGit::Command::Application.new(global_options,
                                     options,
                                     args)

      show = PGit::CurrentProject::Command::Show.new(app)
      show.execute!
    end
  end

  c.desc "run a command"
  c.arg_name 'command_name'
  c.command :run do |r|
    r.action do |global_options,options,args|
      app = PGit::Command::Application.new(global_options,
                                 options,
                                 args)
      run = PGit::Command::Run.new(app)
      run.execute!
    end
  end

  c.desc "add a command"
  c.command :add do |a|
    accept(Array) do |value|
      value.split(',').map {|item| item.strip }
    end
    a.desc "name of the command"
    a.arg_name "new_command_name"
    a.flag :n, :name, required: true

    a.desc "steps of the command, delimited by commas"
    a.arg_name "steps"
    a.flag :s, :steps, required: true, type: Array

    a.action do |global_options,options,args|
      command = PGit::CurrentProject::Command::new(options[:name], options[:steps])
      command.add
    end
  end

  c.desc "update a command"
  c.command :update do |a|
    accept(Array) do |value|
      value.split(',').map {|item| item.strip }
    end
    a.desc "name of the command"
    a.arg_name "new_command_name"
    a.flag :n, :name, required: true

    a.desc "steps of the command, delimited by commas"
    a.arg_name "steps"
    a.flag :s, :steps, required: true, type: Array

    a.action do |global_options,options,args|
      command = PGit::CurrentProject::Command::new(options[:name], options[:steps])
      command.update
    end
  end

  c.desc "remove a command"
  c.command :remove do |a|
    accept(Array) do |value|
      value.split(',').map {|item| item.strip }
    end
    a.desc "name of the command"
    a.arg_name "new_command_name"
    a.flag :n, :name, required: true

    a.action do |global_options,options,args|
      command = PGit::CurrentProject::Command::new(options[:name])
      command.remove
    end
  end
end

desc "Installs the pgit configuration file"
command :install do |c|
  c.action do |global_options,options,args|
    completer = PGit::Installer::BashAutoCompletion.new(global_options,
                                                        options,
                                                        args)
    completer.write_completer_file
    completer.source_completer_from_bashrc

    PGit::Installer::Configuration.new(global_options, options, args)
  end
end

# desc 'Start, finish, etc. Pivotal Tracker story branches'
desc 'Start Pivotal Tracker story branches'
long_desc "Makes a cURL request to Pivotal Tracker to fetch the story, based
on the given story id, parses the title, appends it with the story id. It then
creates a branch name with that parsed title and does a `git checkout` to it.  "

command :story_branch do |c|
  c.desc "Parses the title of the given Pivotal Tracker story,\n" +
    "  makes the branch name, and does a checkout"
  c.arg_name 'STORY_ID'
  c.flag :s, :start

  c.action do |global_options,options,args|
    PGit::StoryBranch::Application.new(global_options, options, args)
  end
end


desc 'Initializes configuration file'
arg_name 'path/to/config_file'

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  Rainbow.enabled = global.fetch(:color)
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  # true
  warn Rainbow("error: #{exception}").color(:red)
  exit 1
end

exit run(ARGV)
